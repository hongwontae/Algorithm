1. Object Big O
1-1. 정렬할 필요가 없을 떄, 빠른 접근과 입력과 제거을 원할 떄 Obj를 사용한다.
1-2. 빠르다는 것은 접근시간이 상수 시간 => O(1)

1-3. 입력, 접근, 삭제 모두 O(1)이다. key를 사용해 저장하는 프로세스다.
1-4. 탐색은 O(N)이다. => 객체의 프로퍼티의 값들 중에 특정한 값을 찾으려면 모든 프로퍼티를 순회해야 알 수 있다.

1-5. Object.keys()/ Object.entries()/ Object.values() => O(n);
1-6. ObjectName.hsaOwnProperty(key) => 해당 obj에 해당 키가 존재하는가? => O(1);


2. Array Big O
2-1. 배열의 가장 큰 특징은 정렬이 되어 있다는 것이다.
2-2. 접근 => O(1); 
=> 배열의 엘리멘트에 접근은 처음 요소부터 시작해 원하는 요소까지 순회하여 도착하지 않는다.
=> 해당 인덱스에 접근하면 바로 접근할 수 있다.

2-3. 입력/제거 => it depends
push => O(1);
pop => O(1);
unShift => O(N);
shift => O(N);
=> 배열의 값을 앞에 추가하면 인덱스를 재정의해야 한다. => 연산 처리 증가
=> 배열으 값을 뒤에 추가하면 인덱스를 +1 해주고 값을 넣어주면 끝난다. => 연산 1번

2-4. concat, splice, slice, forEach, map, filter, reduce.. => O(n);
=> 일반적으로 배열과 관련된 메서드들은 O(n)이다.

2-5. sort => O(n * log N);
=> 배열을 정렬하는 것은 O(n)보다 크다.


